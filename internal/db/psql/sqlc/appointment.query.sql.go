// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: appointment.query.sql

package sqlc

import (
	"context"
	"encoding/json"
	"time"

	zero "gopkg.in/guregu/null.v4/zero"
)

const countDoctorAppointment = `-- name: CountDoctorAppointment :one
SELECT
      COUNT(*)
FROM public.appointments pa
         LEFT JOIN public.users pu ON pa.user_id = pu.id
WHERE pa.doctor_id = $1
  AND
    pu.full_name ILIKE  $2
            OR pu.phone_number ILIKE $2
            OR pa.status::text ILIKE $2
`

type CountDoctorAppointmentParams struct {
	DoctorID zero.String `json:"doctor_id"`
	FullName zero.String `json:"full_name"`
}

func (q *Queries) CountDoctorAppointment(ctx context.Context, arg CountDoctorAppointmentParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDoctorAppointment, arg.DoctorID, arg.FullName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserAppointments = `-- name: CountUserAppointments :one
SELECT
   COUNT(*)
FROM public.appointments pa
         LEFT JOIN public.doctors pd ON pa.doctor_id = pd.id
WHERE pa.user_id = $1 AND
    pd.first_name ILIKE $2
            OR pd.last_name ILIKE $2
            OR pd.specialization ILIKE  $2
            OR pd.treatment_profile ILIKE  $2
            OR pd.professional_activity ILIKE  $2
`

type CountUserAppointmentsParams struct {
	UserID    zero.String `json:"user_id"`
	FirstName string      `json:"first_name"`
}

func (q *Queries) CountUserAppointments(ctx context.Context, arg CountUserAppointmentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserAppointments, arg.UserID, arg.FirstName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOneAppointment = `-- name: DeleteOneAppointment :exec
DELETE FROM public.appointments
WHERE id = $1
`

func (q *Queries) DeleteOneAppointment(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteOneAppointment, id)
	return err
}

const editOneAppointment = `-- name: EditOneAppointment :one
UPDATE public.appointments
SET user_id = $1,
    doctor_id = $2,
    appointment_time = $3,
    updated_at = $4
WHERE id = $5
    RETURNING id
`

type EditOneAppointmentParams struct {
	UserID          zero.String `json:"user_id"`
	DoctorID        zero.String `json:"doctor_id"`
	AppointmentTime time.Time   `json:"appointment_time"`
	UpdatedAt       zero.Time   `json:"updated_at"`
	ID              string      `json:"id"`
}

func (q *Queries) EditOneAppointment(ctx context.Context, arg EditOneAppointmentParams) (string, error) {
	row := q.db.QueryRow(ctx, editOneAppointment,
		arg.UserID,
		arg.DoctorID,
		arg.AppointmentTime,
		arg.UpdatedAt,
		arg.ID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const editOneStatusAppointment = `-- name: EditOneStatusAppointment :one
UPDATE public.appointments
SET status = $1,
    updated_at = $2
WHERE id = $3
    RETURNING id
`

type EditOneStatusAppointmentParams struct {
	Status    NullAppointmentStatus `json:"status"`
	UpdatedAt zero.Time             `json:"updated_at"`
	ID        string                `json:"id"`
}

func (q *Queries) EditOneStatusAppointment(ctx context.Context, arg EditOneStatusAppointmentParams) (string, error) {
	row := q.db.QueryRow(ctx, editOneStatusAppointment, arg.Status, arg.UpdatedAt, arg.ID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const insertOneAppointment = `-- name: InsertOneAppointment :one
INSERT INTO public.appointments (user_id, doctor_id, appointment_time)
VALUES ($1, $2, $3)
    RETURNING id
`

type InsertOneAppointmentParams struct {
	UserID          zero.String `json:"user_id"`
	DoctorID        zero.String `json:"doctor_id"`
	AppointmentTime time.Time   `json:"appointment_time"`
}

func (q *Queries) InsertOneAppointment(ctx context.Context, arg InsertOneAppointmentParams) (string, error) {
	row := q.db.QueryRow(ctx, insertOneAppointment, arg.UserID, arg.DoctorID, arg.AppointmentTime)
	var id string
	err := row.Scan(&id)
	return id, err
}

const selectDoctorAppointments = `-- name: SelectDoctorAppointments :many
SELECT
    pa.id,
    jsonb_build_object(
            'full_name', pu.full_name,
            'phone_number', pu.phone_number
    ) AS user_info,
    pa.appointment_time,
    pa.status,
    pa.created_at,
    pa.updated_at
FROM public.appointments pa
         LEFT JOIN public.users pu ON pa.user_id = pu.id

WHERE pa.doctor_id = $1
  AND
    pu.full_name ILIKE  $2
            OR pu.phone_number ILIKE  $2
            OR pa.status::text ILIKE  $2
 LIMIT $3 OFFSET $4
`

type SelectDoctorAppointmentsParams struct {
	DoctorID zero.String `json:"doctor_id"`
	FullName zero.String `json:"full_name"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type SelectDoctorAppointmentsRow struct {
	ID              string                `json:"id"`
	UserInfo        json.RawMessage       `json:"user_info"`
	AppointmentTime time.Time             `json:"appointment_time"`
	Status          NullAppointmentStatus `json:"status"`
	CreatedAt       zero.Time             `json:"created_at"`
	UpdatedAt       zero.Time             `json:"updated_at"`
}

func (q *Queries) SelectDoctorAppointments(ctx context.Context, arg SelectDoctorAppointmentsParams) ([]SelectDoctorAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, selectDoctorAppointments,
		arg.DoctorID,
		arg.FullName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectDoctorAppointmentsRow
	for rows.Next() {
		var i SelectDoctorAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserInfo,
			&i.AppointmentTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserAppointments = `-- name: SelectUserAppointments :many
SELECT
    pa.id,
    jsonb_build_object(
            'first_name', pd.first_name,
            'last_name', pd.last_name,
            'image', pd.image,
            'experience', pd.experience,
            'specialization', pd.specialization
    ) AS doctor_info,
    pa.appointment_time,
    pa.status,
    pa.created_at,
    pa.updated_at
FROM public.appointments pa
         LEFT JOIN public.doctors pd ON pa.doctor_id = pd.id
WHERE pa.user_id = $1 AND
           pd.first_name ILIKE  $2
            OR pd.last_name ILIKE  $2
            OR pd.specialization ILIKE  $2
            OR pd.treatment_profile ILIKE  $2
            OR pd.professional_activity ILIKE  $2

    LIMIT $3 OFFSET $4
`

type SelectUserAppointmentsParams struct {
	UserID    zero.String `json:"user_id"`
	FirstName string      `json:"first_name"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type SelectUserAppointmentsRow struct {
	ID              string                `json:"id"`
	DoctorInfo      json.RawMessage       `json:"doctor_info"`
	AppointmentTime time.Time             `json:"appointment_time"`
	Status          NullAppointmentStatus `json:"status"`
	CreatedAt       zero.Time             `json:"created_at"`
	UpdatedAt       zero.Time             `json:"updated_at"`
}

func (q *Queries) SelectUserAppointments(ctx context.Context, arg SelectUserAppointmentsParams) ([]SelectUserAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, selectUserAppointments,
		arg.UserID,
		arg.FirstName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectUserAppointmentsRow
	for rows.Next() {

		var i SelectUserAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.DoctorInfo,
			&i.AppointmentTime,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, nil
}
