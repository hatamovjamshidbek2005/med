// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: notiification.query.sql

package sqlc

import (
	"context"
	"time"

	zero "gopkg.in/guregu/null.v4/zero"
)

const insertNotification = `-- name: InsertNotification :one
INSERT INTO public.notifications (
    appointment_id, user_id, doctor_id, scheduled_at, message
) VALUES (
             $1, $2, $3, $4, $5
         ) RETURNING id
`

type InsertNotificationParams struct {
	AppointmentID zero.String `json:"appointment_id"`
	UserID        zero.String `json:"user_id"`
	DoctorID      zero.String `json:"doctor_id"`
	ScheduledAt   time.Time   `json:"scheduled_at"`
	Message       string      `json:"message"`
}

func (q *Queries) InsertNotification(ctx context.Context, arg InsertNotificationParams) (string, error) {
	row := q.db.QueryRow(ctx, insertNotification,
		arg.AppointmentID,
		arg.UserID,
		arg.DoctorID,
		arg.ScheduledAt,
		arg.Message,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const selectPendingNotifications = `-- name: SelectPendingNotifications :many
SELECT
    n.id, n.appointment_id, n.user_id, n.doctor_id, n.scheduled_at, n.message,
    u.full_name, u.email,
    d.first_name AS doctor_first_name, d.last_name AS doctor_last_name
FROM public.notifications n
         JOIN public.users u ON n.user_id = u.id
         JOIN public.doctors d ON n.doctor_id = d.id
WHERE n.status = 'pending' AND n.scheduled_at <= NOW()
`

type SelectPendingNotificationsRow struct {
	ID              string      `json:"id"`
	AppointmentID   zero.String `json:"appointment_id"`
	UserID          zero.String `json:"user_id"`
	DoctorID        zero.String `json:"doctor_id"`
	ScheduledAt     time.Time   `json:"scheduled_at"`
	Message         string      `json:"message"`
	FullName        zero.String `json:"full_name"`
	Email           zero.String `json:"email"`
	DoctorFirstName string      `json:"doctor_first_name"`
	DoctorLastName  string      `json:"doctor_last_name"`
}

func (q *Queries) SelectPendingNotifications(ctx context.Context) ([]SelectPendingNotificationsRow, error) {
	rows, err := q.db.Query(ctx, selectPendingNotifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectPendingNotificationsRow
	for rows.Next() {
		var i SelectPendingNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.AppointmentID,
			&i.UserID,
			&i.DoctorID,
			&i.ScheduledAt,
			&i.Message,
			&i.FullName,
			&i.Email,
			&i.DoctorFirstName,
			&i.DoctorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNotificationStatus = `-- name: UpdateNotificationStatus :exec
UPDATE public.notifications
SET status = $1, sent_at = NOW()
WHERE id = $2
`

type UpdateNotificationStatusParams struct {
	Status zero.String `json:"status"`
	ID     string      `json:"id"`
}

func (q *Queries) UpdateNotificationStatus(ctx context.Context, arg UpdateNotificationStatusParams) error {
	_, err := q.db.Exec(ctx, updateNotificationStatus, arg.Status, arg.ID)
	return err
}
